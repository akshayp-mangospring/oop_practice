I've noticed that it happens with new and somewhat experienced programmers as well. They tend to migrate their habits from one language to another. This often happens when they are trying to learn their second programming language, after having the habit of building programs in one language for a long time. Programmers rush to learn the next language, often to add it to their tech stack or as a requirement for a new project, and in the process, they tend to bring their habits from the language they already know with them. They come with all the good intentions and strong opinions with the analogy that the way stuff works in the previous language must also work in the next language as well. It can start off with the basic things such as naming conventions, then move along to other stuff such as idiomatic ways of writing programs in the language they are trying to learn. I myself was a victim of this situation and have seen many others fall into this trap.

Let me share a quick example: My initial languages required to be learnt while starting to work professionally were HTML, CSS—UI development. At the time, our UI development team had a convention of `camelCased` classnames and ids to be placed on the DOM elements, which I kind of disagreed with since we also used the Bootstrap framework on many projects to build our UI, which followed the convention of hyphenated `class-names` on the DOM, so I was more of the opinion that we should stick to Bootstrap's way or should follow BEM for naming things on the DOM. But the counter argument given to me was that to differentiate our code quickly from the library code, such as Bootstrap classes or any other UI framework, we must follow a convention that no framework follows. I didn't rebel much with the team at the time since I thought it was more important to build software than to debate about conventions, thus the `camelCased` classnames stuck on our projects. Coincidentally, our JavaScript (JS) team also had the convention of `camelCased` variables, so it didn't matter much to me. The next language which I learnt as a part of natural progression was JS, so my first actual programming language was JS. I learnt to do stuff in JS the JS way—prototypal inheritance, functional programming, event loop, etc. But I hit a reality check when I started learning Go—It's a totally different paradigm to program in Go than in JS; it has strict typing; pointers, structs, channels, goroutines, no prototypes. It has a plethora of things to learn and its own set of principles to achieve things. The same goes for Ruby—object-oriented, dynamically typed, convention over configuration, `snake_cased_variables`, developer ease of use, readability, and no mention of functional programming. The communities of almost all the popular languages are very opinionated about how we should write software in that language. I had a hard time wrapping my head around the conventions, concepts, and workflows followed in each language. I am sure some of us must have also faced the same situation. But it struck me that most of the time, it's valid to have certain conventions in certain languages since each language is designed to solve a different type of problem. Also, ridiculing other experienced developers' opinions just for the sake of our own comfort or convention is totally unjust. We need not get married to our conventions or habits—they need to be flexible enough to be modified or scrapped.

Thus, I want to urge all developers to have a more accepting view towards the idomatic way of doing things in different languages. Go has a different idomatic way than Ruby. The same goes for JS, Java, and other languages as well. Whenever learning any programming language or working in any programming language, we must make sure that we also learn the idiomatic way of doing things in that language and should be able to switch our habits easily from one language to another and not try to enforce other language conventions on a language for our own convenience since each language has its own way of doing things.

This same analogy applies to databases as well. It happened to me when I first learnt MySql and then MongoDB. Both have different ways of doing the same thing since the idea behind the design and functioning of each DB was totally different. This analogy can be extended to frameworks or software tools as well. For example, if Git works in a certain way, we might expect SVN to also work in the same way, since both do code versioning, but no, there are some differences. There can also be subtle differences as well within the same domain, such as Bitbucket and Github.

In such cases, we need to master the skill of context switching. We need to take a deep breath, relax, make up our mind, and switch habits or conventions to know how to work within that specific language or framework or tool. This principle applies almost universally to software development and software products as well.

But the most important thing I want to point out here is that the exchange of ideas or conventions across different programming languages or domains is not a bad thing. It is a thing to be discussed as widely as possible with no hard feelings whatsoever. It is something that should be explored and thought over by new and experienced programmers alike. It might help the language designers or software developers to add some critical features that they might be missing from the software. Since that's how we grow.
